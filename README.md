# World-Routing-on-Risk-Map
This project is a Java command-line routing application that models the classic Risk map as a graph to compute shortest international routes and fuel consumption. On startup, the program loads 42 countries, their continents, and traversal fuel costs from countries.csv, plus undirected adjacencies from adjacencies.csv. The map is represented with a LinkedHashMap<Country, List<Country>> so traversal respects the file’s neighbor order—important for deterministic breadth-first search (BFS) results when multiple shortest paths exist. The CLI exposes two key commands: INFO-COUNTRY, which prints a country’s continent, fuel cost, and ordered neighbors, and ROUTE, which asks for a source and destination, then uses BFS with a Queue<Country> (via LinkedList) and a HashSet for visited tracking to discover the minimum-hop path. The route is reconstructed by parent pointers into a List<String> and printed as [A, B, C, ...]. Fuel is calculated only on intermediate countries (origin and destination excluded) and is also aggregated by continent to produce [Continent (fuel)] in first-appearance order; the program highlights the continent with the maximum spend (ties resolved by first appearance). Input handling is resilient and user-friendly: names are case-sensitive but normalized with a provided utility that capitalizes the first letter of each word; invalid names trigger a custom CountryNotFoundException thrown from the lookup layer and caught by the command loop to re-prompt without crashing. Output formatting strictly follows MessageCli templates to align with the course’s system-level tests. The code avoids non-final static fields to prevent cross-test state leakage, keeps state instance-scoped, and is organized around small, cohesive classes (e.g., MapEngine, Graph, Country, CountryIndex, and the custom exception) for clarity and maintainability. Built with Maven; easily testable and extensible for weighted routing or additional analytics.
